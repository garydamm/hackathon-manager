# Progress Log

## Learnings
(Patterns discovered during implementation)

---

## Iteration 16 - Create EventAttendeeRepository
- Created EventAttendeeRepository.kt extending JpaRepository
- Added methods: findByEventIdAndUserId, findByEventIdOrderByUserLastNameAscUserFirstNameAsc, existsByEventIdAndUserId, countByEventIdAndRsvpStatus, deleteByEventIdAndUserId
- Files changed:
  - src/main/kotlin/com/hackathon/manager/repository/EventAttendeeRepository.kt (created)
- Learnings for future iterations:
  - Repository pattern follows standard Spring Data JPA conventions
  - Method names follow query derivation pattern: findBy/existsBy/countBy/deleteBy + property combinations
  - EventAttendee entity already existed with proper relationships to ScheduleEvent and User
  - Repositories are simple interfaces - Spring generates implementation automatically
---

## Iteration 17 - Add EventAttendee DTOs
- Created EventAttendeeDtos.kt with all required DTOs
- Added EventAttendeeResponse with fromEntity() companion method that extracts user details from the EventAttendee entity
- Added RsvpRequest with @Pattern validation for rsvpStatus (attending|maybe|not_attending)
- Added MarkAttendanceRequest for single user attendance tracking
- Added BulkMarkAttendanceRequest for marking multiple users at once
- Files changed:
  - src/main/kotlin/com/hackathon/manager/dto/EventAttendeeDtos.kt (created)
  - PRD.md (marked US-002 complete)
- Learnings for future iterations:
  - DTO pattern follows existing codebase conventions with data classes and validation annotations
  - Response DTOs use companion object with fromEntity() factory method
  - Request DTOs use Jakarta validation annotations (@NotBlank, @NotNull, @Pattern)
  - @Pattern annotation validates enum-like string values for rsvpStatus
  - EventAttendeeResponse includes user details (firstName, lastName, email) by accessing attendee.user properties
---

## Iteration 18 - Update ScheduleEventResponse with RSVP data
- Updated ScheduleEventResponse data class to include RSVP and attendance fields
- Added 5 new fields: attendingCount, maybeCount, notAttendingCount, userRsvpStatus, userAttended
- Updated fromEntity() companion method signature to accept RSVP counts and optional EventAttendee
- Added EventAttendee import to ScheduleEventDtos.kt
- Files changed:
  - src/main/kotlin/com/hackathon/manager/dto/ScheduleEventDtos.kt
  - PRD.md (marked US-003 complete)
- Learnings for future iterations:
  - Response DTOs can be enhanced with additional optional parameters in fromEntity() to support different contexts
  - Default parameter values (= 0, = null) allow backwards compatibility when updating DTOs
  - RSVP counts are passed separately from the entity since they require aggregation queries
  - userAttendee parameter is nullable to support both authenticated and unauthenticated requests
---

## Iteration 19 - Add isUserRegistered helper to HackathonService
- Added isUserRegistered(hackathonId, userId) method to HackathonService
- Method uses hackathonUserRepository.existsByHackathonIdAndUserId() to return boolean
- Added @Transactional(readOnly = true) annotation following service layer pattern
- Files changed:
  - src/main/kotlin/com/hackathon/manager/service/HackathonService.kt
  - PRD.md (marked US-004 complete)
- Learnings for future iterations:
  - HackathonUserRepository already has existsByHackathonIdAndUserId() method
  - Helper methods in service layer should follow @Transactional(readOnly = true) pattern for read operations
  - isUserRegistered checks if user has ANY role in the hackathon (organizer, judge, admin, or participant)
  - This is useful for RSVP validation - any registered user can RSVP to events
---

## Iteration 20 - Add RSVP service methods to ScheduleService
- Injected eventAttendeeRepository, userRepository, and hackathonService into ScheduleService constructor
- Added getScheduleByHackathonWithRsvp(hackathonId, userId?) method that includes RSVP counts per event
- Added rsvpToEvent(eventId, userId, rsvpStatus) method that creates or updates RSVP with full validation
- Added removeRsvp(eventId, userId) method that deletes RSVP records
- Files changed:
  - src/main/kotlin/com/hackathon/manager/service/ScheduleService.kt
  - PRD.md (marked US-005 complete)
- Learnings for future iterations:
  - countByEventIdAndRsvpStatus returns Long, must convert to Int using .toInt() for ScheduleEventResponse
  - getScheduleByHackathonWithRsvp queries RSVP counts for each event and includes user's RSVP status if userId provided
  - rsvpToEvent validates: rsvpStatus enum, event exists, user exists, and user is registered for hackathon
  - When creating/updating RSVP, use findByEventIdAndUserId() first, create new EventAttendee if null
  - removeRsvp uses deleteByEventIdAndUserId() which is safe even if record doesn't exist
  - Service layer handles all business logic and validation before repository operations
---

## Iteration 21 - Add attendance tracking service methods
- Added three methods to ScheduleService for organizer-only attendance tracking
- Added getEventAttendees(eventId, requesterId) that returns sorted list of attendees with RSVP/attendance data
- Added markAttendance(eventId, userId, attended, requesterId) for marking single user attendance
- Added bulkMarkAttendance(eventId, userIds, attended, requesterId) for marking multiple users at once
- Files changed:
  - src/main/kotlin/com/hackathon/manager/service/ScheduleService.kt
  - PRD.md (marked US-006 complete)
- Learnings for future iterations:
  - Authorization pattern: validate entity exists first, then check isUserOrganizer() before any operations
  - All attendance methods throw ApiException with FORBIDDEN status if requester is not organizer
  - markAttendance and bulkMarkAttendance create EventAttendee records if they don't exist (similar to RSVP pattern)
  - getEventAttendees uses findByEventIdOrderByUserLastNameAscUserFirstNameAsc for alphabetical sorting
  - bulkMarkAttendance validates each userId exists before updating to provide specific error messages
  - EventAttendeeResponse.fromEntity() imported to return properly formatted attendee lists
---

## Iteration 22 - Add RSVP endpoints to ScheduleController
- Updated existing GET /schedule/hackathon/{hackathonId} to use getScheduleByHackathonWithRsvp()
- Added POST /schedule/{eventId}/rsvp endpoint that creates new RSVP and returns 201 CREATED
- Added PUT /schedule/{eventId}/rsvp endpoint that updates existing RSVP and returns 200 OK
- Added DELETE /schedule/{eventId}/rsvp endpoint that removes RSVP and returns 204 NO CONTENT
- Files changed:
  - src/main/kotlin/com/hackathon/manager/controller/ScheduleController.kt
  - PRD.md (marked US-007 complete)
- Learnings for future iterations:
  - GET endpoint accepts nullable @AuthenticationPrincipal to support both authenticated and unauthenticated requests
  - POST and PUT endpoints both call rsvpToEvent() service method (creates or updates)
  - All RSVP endpoints require authentication since they use @AuthenticationPrincipal principal (non-nullable)
  - RsvpRequest DTO includes validation, so @Valid annotation ensures proper validation
  - Service layer returns ScheduleEventResponse with updated RSVP counts for immediate UI feedback
  - DELETE endpoint uses noContent() for 204 status with no body
---

## Iteration 23 - Add attendance tracking endpoints
- Added three endpoints to ScheduleController for organizer attendance tracking
- Added GET /schedule/{eventId}/attendees that returns List<EventAttendeeResponse>
- Added POST /schedule/{eventId}/attendance with MarkAttendanceRequest body for single user
- Added POST /schedule/{eventId}/attendance/bulk with BulkMarkAttendanceRequest body for multiple users
- Files changed:
  - src/main/kotlin/com/hackathon/manager/controller/ScheduleController.kt
  - PRD.md (marked US-008 complete)
- Learnings for future iterations:
  - Service methods markAttendance and bulkMarkAttendance return Unit (void), not entities
  - POST endpoints for attendance return ResponseEntity<Void> with 200 OK status using .ok().build()
  - All three endpoints require authentication and pass principal.id to service layer for organizer check
  - Service layer handles all authorization validation (throws FORBIDDEN if not organizer)
  - GET attendees endpoint returns full list with user details, RSVP status, and attendance flag
  - Import statements needed: BulkMarkAttendanceRequest, EventAttendeeResponse, MarkAttendanceRequest
---

## Iteration 24 - Add TypeScript types for schedule and events
- Added all required TypeScript types to frontend/src/types/index.ts
- Added EventType union type with 7 event types: workshop, presentation, meal, deadline, ceremony, networking, other
- Added RsvpStatus union type with 3 statuses: attending, maybe, not_attending
- Added ScheduleEvent interface with all fields including RSVP counts and user-specific fields
- Added EventAttendee interface with user details, RSVP status, and attendance flag
- Added CreateScheduleEventRequest and UpdateScheduleEventRequest interfaces for event management
- Added RsvpRequest, MarkAttendanceRequest, and BulkMarkAttendanceRequest interfaces for RSVP and attendance operations
- Files changed:
  - frontend/src/types/index.ts
  - PRD.md (marked US-009 complete)
- Learnings for future iterations:
  - Frontend types should match backend DTO structure for consistency
  - Union types are preferred over enums in TypeScript for string literal types
  - All optional fields use `| null` for consistency with backend nullable types
  - Build command (`npm run build`) runs `tsc -b` which performs type checking
  - Request interfaces use optional fields for partial updates (UpdateScheduleEventRequest)
---

## Iteration 25 - Create schedule API service
- Created frontend/src/services/schedule.ts with all required methods
- Exported scheduleService singleton object with 11 methods
- Schedule retrieval: getSchedule(hackathonId), getEvent(eventId)
- Event management: createEvent, updateEvent, deleteEvent
- RSVP operations: rsvpToEvent, updateRsvp, removeRsvp
- Attendance tracking: getEventAttendees, markAttendance, bulkMarkAttendance
- Files changed:
  - frontend/src/services/schedule.ts (created)
  - PRD.md (marked US-010 complete)
- Learnings for future iterations:
  - Frontend service pattern uses singleton object exported from file
  - All methods use centralized api client from ./api for consistent error handling and auth
  - Method signatures follow pattern: async methodName(params): Promise<ResponseType>
  - DELETE endpoints return Promise<void> since they return 204 NO CONTENT
  - POST/PUT endpoints for mutations return the updated entity for immediate UI feedback
  - Import types from @/types for proper type safety
  - Service endpoints match backend controller paths exactly
---

## Iteration 26 - Create RsvpButton component
- Created frontend/src/components/RsvpButton.tsx with dropdown menu for RSVP operations
- Created frontend/src/components/ui/dropdown-menu.tsx using @radix-ui/react-dropdown-menu
- Installed @radix-ui/react-dropdown-menu package (53 new packages)
- RsvpButton shows "RSVP" button when no RSVP exists, or color-coded badge when user has RSVP'd
- Dropdown menu with 4 options: Attending (green Check icon), Maybe (yellow HelpCircle), Not Attending (gray X), Remove RSVP
- Uses useMutation for rsvpToEvent, updateRsvp, and removeRsvp operations
- Handles loading states with Loader2 spinner
- Invalidates schedule queries on success for immediate UI feedback
- Files changed:
  - frontend/src/components/RsvpButton.tsx (created)
  - frontend/src/components/ui/dropdown-menu.tsx (created)
  - frontend/package.json, frontend/package-lock.json (added dependency)
  - PRD.md (marked US-011 complete)
- Learnings for future iterations:
  - Dropdown menu pattern uses DropdownMenu, DropdownMenuTrigger, DropdownMenuContent, DropdownMenuItem from shadcn/ui
  - Button can be used as DropdownMenuTrigger with asChild prop
  - Badge component supports custom className for color-coding (bg-green-100 text-green-700, etc.)
  - useMutation pattern: define mutationFn, handle onSuccess with queryClient.invalidateQueries
  - Component differentiates between create (no userRsvpStatus) and update (has userRsvpStatus) operations
  - Loading state disables both trigger button and menu items (isPending check)
  - Remove RSVP option only shown when userRsvpStatus exists (conditional separator and menu item)
---

## Iteration 27 - Create Schedule page with timeline view
- Created frontend/src/pages/Schedule.tsx with complete timeline view functionality
- Component fetches hackathon by slug, then schedule by hackathonId using dependent queries
- Implemented groupEventsByDay() helper function to group events by formatted date string
- Created EventCard component showing name, description, type badge, time, location, virtual link, RSVP counts
- Added mandatory indicator (red badge with AlertCircle icon and "Required" text)
- Virtual link shown with Video icon, opens in new tab with noopener noreferrer
- Integrated RsvpButton component in each event card header
- Added "Back to Hackathon" link with ArrowLeft icon
- Implemented empty state with Calendar icon and helpful message
- Files changed:
  - frontend/src/pages/Schedule.tsx (created)
  - PRD.md (marked US-012 complete)
- Learnings for future iterations:
  - Page follows AppLayout pattern with max-w-4xl container
  - Dependent queries pattern: enable second query only when first query has data (enabled: !!hackathon?.id)
  - groupEventsByDay() uses reduce to create object with date string keys
  - toLocaleDateString() with full options creates readable date headers: "Monday, January 27, 2026"
  - toLocaleTimeString() for time formatting: "9:00 AM"
  - EventCard uses Card with CardHeader and CardContent following existing component patterns
  - Badge color coding follows pattern: bg-{color}-100 text-{color}-700 border-{color}-200
  - Event type mapping: workshop (purple), presentation (blue), meal (orange), deadline (red), ceremony (yellow), networking (green), other (gray)
  - RSVP count display: shows attending always, adds maybe/not attending counts conditionally if > 0
  - Virtual links should use target="_blank" rel="noopener noreferrer" for security
---

## Iteration 28 - Add schedule route to app
- Imported SchedulePage component in App.tsx
- Added route /hackathons/:slug/schedule as a protected route
- Route follows existing pattern with ProtectedRoute wrapper
- Files changed:
  - frontend/src/App.tsx
  - PRD.md (marked US-013 complete)
- Learnings for future iterations:
  - New routes should be added in logical order (schedule route goes between hackathon detail and teams routes)
  - All authenticated routes use ProtectedRoute wrapper component
  - Route path follows pattern: /hackathons/:slug/<feature>
  - Dev server starts successfully on available port (5176 in this case, as 5173-5175 were in use)
  - Import statements should be grouped with other page imports at the top
---

## Iteration 29 - Create EventFormModal component
- Created frontend/src/components/EventFormModal.tsx following CriteriaFormModal pattern
- Implemented React Hook Form with Zod validation for all event fields
- Added all required fields: name*, description, eventType dropdown, location, virtualLink (URL validation), startsAt*, endsAt* (datetime-local), isMandatory (Switch)
- Supports both create and edit modes detected via event prop
- Uses framer-motion for modal animations (backdrop and modal)
- Shows validation errors inline using react-hook-form errors
- Handles create/update mutations with loading states (Loader2 spinner)
- Invalidates schedule queries on success for immediate UI feedback
- Files changed:
  - frontend/src/components/EventFormModal.tsx (created)
  - PRD.md (marked US-014 complete)
- Learnings for future iterations:
  - EventFormModal follows exact same pattern as CriteriaFormModal (modal structure, animations, form handling)
  - Switch component requires watch() and setValue() pattern for controlled behavior with react-hook-form
  - datetime-local input type requires ISO string conversion: toISOString().slice(0, 16) for editing
  - Form submission converts datetime-local back to ISO: new Date(data.startsAt).toISOString()
  - CreateScheduleEventRequest includes hackathonId in the request body, not as separate parameter
  - Virtual link validation uses z.string().url().optional().or(z.literal("")) to allow empty string
  - Modal uses max-w-2xl for wider layout due to more fields, and max-h-[90vh] overflow-y-auto for scrolling
  - Event type dropdown uses native <select> with input styling classes for consistency
  - isMandatory uses Switch component with controlled behavior via watch/setValue pattern
---

## Iteration 30 - Create DeleteEventModal component
- Created frontend/src/components/DeleteEventModal.tsx following EventFormModal pattern
- Shows warning with AlertTriangle icon in header alongside "Delete Event" title
- Displays event name in bold within confirmation message
- Warns user that RSVPs and attendance records will also be deleted
- Uses destructive button variant (variant="destructive") for delete action
- Handles delete mutation with loading state (Loader2 spinner and "Deleting..." text)
- Invalidates schedule queries on success for immediate UI feedback
- Files changed:
  - frontend/src/components/DeleteEventModal.tsx (created)
  - PRD.md (marked US-015 complete)
- Learnings for future iterations:
  - DeleteEventModal follows same modal pattern as EventFormModal (framer-motion animations, backdrop, error handling)
  - Modal is simpler than form modal (max-w-md instead of max-w-2xl, no form validation)
  - AlertTriangle icon shown in header with text-destructive color to emphasize danger
  - Component receives event prop and returns null early if event is null for safety
  - Confirmation message uses span with font-semibold and text-foreground to highlight event name
  - Delete button uses variant="destructive" for red button styling
  - Warning text explains consequences: "All RSVPs and attendance records for this event will also be deleted"
  - Mutation pattern same as EventFormModal: useMutation with mutationFn, onSuccess, onError
---

## Iteration 31 - Create AttendanceModal component
- Created frontend/src/components/AttendanceModal.tsx with complete attendance tracking functionality
- Modal fetches attendees using useQuery when opened with staleTime: 0 for fresh data
- Displays attendee list with name, email, and color-coded RSVP status badges (green for attending, yellow for maybe, gray for not attending)
- Implemented checkbox multi-select with "Select All" option at the top
- Each attendee row shows Present/Absent button that toggles attended status (green highlight when present)
- Bulk action buttons appear when items selected: "Mark Present" and "Mark Absent"
- Displays present count: "X / Y present" below event name
- Handles individual markAttendance mutation for single user toggle
- Handles bulkMarkAttendance mutation for marking multiple selected users at once
- Invalidates both eventAttendees and schedule queries on success for immediate UI feedback
- Shows loading state with Loader2 spinner during mutations
- Empty state when no attendees have RSVP'd yet
- Files changed:
  - frontend/src/components/AttendanceModal.tsx (created)
  - PRD.md (marked US-016 complete)
- Learnings for future iterations:
  - Checkbox component not needed - native HTML checkboxes work well with Tailwind styling
  - useQuery with enabled: isOpen && !!event prevents unnecessary fetches when modal closed
  - staleTime: 0 ensures fresh data is fetched every time modal opens (important for attendance tracking)
  - Set<string> for selectedUserIds provides efficient add/remove operations
  - Reset selectedUserIds in useEffect when modal closes to clear selection state
  - Bulk mutations should clear selection on success (setSelectedUserIds(new Set()))
  - Button styling for Present state: bg-green-50 text-green-700 border-green-200 hover:bg-green-100
  - Native checkbox styling: h-4 w-4 rounded border-gray-300 text-primary focus:ring-primary
  - Modal uses max-w-2xl and max-h-[90vh] overflow-y-auto for scrollable list of attendees
  - Display pattern: checkbox, attendee info (name/email), RSVP badge, Present/Absent button in one row
---

## Iteration 32 - Create ScheduleManagementSection component
- Created frontend/src/components/ScheduleManagementSection.tsx following JudgingCriteriaSection pattern exactly
- Component fetches schedule using useQuery with queryKey: ["schedule", hackathonId]
- Displays Card with "Schedule & Events" title and Calendar icon in header
- Shows "Add Event" button in header with Plus icon
- Lists all events with: name, type badge (color-coded), mandatory indicator (red Required badge with AlertCircle), formatted time, location, RSVP counts
- Each event has 3 action buttons: Attendance (Users icon), Edit (Pencil), Delete (Trash2)
- Manages state for 3 modals: EventFormModal, DeleteEventModal, AttendanceModal
- Shows empty state message when no events scheduled
- Files changed:
  - frontend/src/components/ScheduleManagementSection.tsx (created)
  - PRD.md (marked US-017 complete)
- Learnings for future iterations:
  - Component follows exact same pattern as JudgingCriteriaSection with 3 modals and selection state
  - formatEventTime() helper function creates readable time range: "Jan 27, 9:00 AM - 10:30 AM"
  - Event type badge colors use Record<string, string> for type safety with fallback to other color
  - RSVP count display follows same pattern as Schedule page: attending always shown, maybe/not attending conditionally
  - Three separate state handlers for three modals: handleFormModalClose, handleDeleteModalClose, handleAttendanceModalClose
  - Modal components receive different props: EventFormModal needs hackathonId and event, DeleteEventModal needs event, AttendanceModal needs event
  - Loading state shows centered Loader2 spinner during data fetch
---

## Iteration 33 - Integrate schedule into HackathonDetail page
- Imported ScheduleManagementSection component in HackathonDetail.tsx
- Added ScheduleManagementSection after JudgesSection with isOrganizer check (line 478)
- Added "View Full Schedule" card in Quick Info section after Participants card
- Card is visible to all registered users (checks hackathon.userRole) with Calendar icon
- Card links to /hackathons/{slug}/schedule with hover effects
- Files changed:
  - frontend/src/pages/HackathonDetail.tsx
  - PRD.md (marked US-018 complete)
- Learnings for future iterations:
  - Integration pattern: import component, add with conditional rendering (isOrganizer check)
  - Quick Info cards use Card with CardContent, flex layout, and icon + text layout
  - "View Full Schedule" card uses bg-primary/5 and border-primary/20 for subtle highlighting
  - Link component wraps entire card content with group class for hover effects
  - ArrowLeft icon rotated 180 degrees (rotate-180) to point right, with translate animation on hover
  - Conditional rendering based on userRole checks if user is registered (any role)
  - ScheduleManagementSection placed between JudgesSection and LeaderboardSection following component ordering pattern
---

## Iteration 34 - Add Checkbox UI component
- Verified that checkbox.tsx component did not exist in the codebase
- Installed @radix-ui/react-checkbox package (4 new packages added)
- Created frontend/src/components/ui/checkbox.tsx following shadcn/ui patterns
- Component uses CheckboxPrimitive.Root and CheckboxPrimitive.Indicator from @radix-ui/react-checkbox
- Uses Check icon from lucide-react for the checked state indicator
- Follows existing component pattern: React.forwardRef with proper TypeScript types
- Includes proper styling with focus states, disabled states, and checked states
- Files changed:
  - frontend/src/components/ui/checkbox.tsx (created)
  - frontend/package.json, frontend/package-lock.json (added @radix-ui/react-checkbox)
  - PRD.md (marked US-019 complete)
- Learnings for future iterations:
  - Checkbox component follows same pattern as other shadcn/ui components (Button, Label)
  - Uses React.forwardRef with ElementRef and ComponentPropsWithoutRef types from @radix-ui
  - Styling uses data-[state=checked] selector for checked state styling
  - CheckboxPrimitive.Indicator only renders when checkbox is checked (conditional rendering built-in)
  - Component size (h-4 w-4) matches native checkbox size used in AttendanceModal for consistency
  - While native HTML checkboxes work fine, shadcn/ui Checkbox provides better accessibility and styling consistency
  - cn utility function from @/lib/utils merges Tailwind classes properly
  - displayName property set to match primitive component name for React DevTools
---

## Iteration 35 - Add password_reset_tokens table
- Created V2__add_password_reset_tokens.sql migration file
- Table includes: id (UUID primary key), user_id (foreign key to users with CASCADE delete), token (VARCHAR 255 unique), expires_at (TIMESTAMP), created_at (TIMESTAMP default now), used_at (TIMESTAMP nullable)
- Added index on token column for fast lookups during password reset validation
- Added index on user_id column to support cleanup queries
- Migration successfully applied to database (Flyway validated and migrated to version 2)
- Files changed:
  - src/main/resources/db/migration/V2__add_password_reset_tokens.sql (created)
  - PRD.md (marked US-001 complete)
- Learnings for future iterations:
  - Migration file naming follows pattern: V{version}__{description}.sql
  - Use TIMESTAMP WITH TIME ZONE for all timestamp columns to match existing schema
  - ON DELETE CASCADE ensures tokens are removed when user is deleted
  - UNIQUE constraint on token column prevents duplicate tokens
  - Indexes should be added for columns used in WHERE clauses (token for validation, user_id for cleanup)
  - Flyway automatically validates and applies new migrations on application startup
  - Application logs show successful migration: "Successfully applied 1 migration to schema 'public', now at version v2"
---

## Iteration 36 - Create PasswordResetToken entity
- Created PasswordResetToken.kt entity following existing entity patterns
- Mapped all table columns: id (UUID), user (ManyToOne to User), token (String), expiresAt (OffsetDateTime), createdAt (OffsetDateTime with @CreationTimestamp), usedAt (nullable OffsetDateTime)
- Added @ManyToOne relationship to User entity with LAZY fetch type
- Added helper method isExpired() that checks if current time is after expiresAt
- Added helper method isUsed() that checks if usedAt is not null
- Files changed:
  - src/main/kotlin/com/hackathon/manager/entity/PasswordResetToken.kt (created)
  - PRD.md (marked US-002 complete)
- Learnings for future iterations:
  - Entity pattern follows existing conventions: @Entity, @Table, primary constructor with properties
  - Use @ManyToOne with fetch = FetchType.LAZY for relationships to avoid eager loading
  - @CreationTimestamp handles createdAt automatically (updatable = false)
  - Helper methods can be added to entity classes for business logic convenience
  - OffsetDateTime.now() used for current time comparison in isExpired()
  - Token column has unique = true and length = 255 matching migration definition
---

## Iteration 37 - Create PasswordResetTokenRepository
- Created PasswordResetTokenRepository.kt extending JpaRepository
- Added method: findByToken(token: String) for token validation during password reset
- Added method: findByUserIdAndUsedAtIsNullAndExpiresAtAfter(userId, currentTime) for finding active tokens
- Added method: deleteByExpiresAtBefore(cutoffTime) for cleanup operations (returns Int count)
- Files changed:
  - src/main/kotlin/com/hackathon/manager/repository/PasswordResetTokenRepository.kt (created)
  - PRD.md (marked US-003 complete)
- Learnings for future iterations:
  - Repository follows Spring Data JPA query derivation pattern for method names
  - findByUserIdAndUsedAtIsNullAndExpiresAtAfter queries for unused, non-expired tokens for a user
  - deleteByExpiresAtBefore returns Int (count of deleted rows) for logging/monitoring purposes
  - Optional<T> used for single result queries that may not exist (findByToken)
  - List<T> used for queries that may return multiple results
  - @Repository annotation marks interface for component scanning
---

## Iteration 38 - Add password reset DTOs
- Created PasswordResetDtos.kt in dto/auth package with three data classes
- Added ForgotPasswordRequest with email field validated with @Email annotation
- Added ResetPasswordRequest with token, newPassword, confirmPassword fields and @Size(min=8) validation
- Added PasswordResetResponse with message field for success/error responses
- Files changed:
  - src/main/kotlin/com/hackathon/manager/dto/auth/PasswordResetDtos.kt (created)
  - PRD.md (marked US-004 complete)
- Learnings for future iterations:
  - DTO pattern follows existing AuthDtos.kt conventions with @field: prefix for validation annotations
  - Password validation uses @Size(min = 8) annotation to enforce minimum length
  - Service-level password requirements check (uppercase, lowercase, number) will be implemented in UserService
  - ForgotPasswordRequest is simple with only email field to prevent user enumeration
  - ResetPasswordRequest requires confirmPassword field for frontend validation before service call
  - PasswordResetResponse is simple success/error wrapper with message field
---

## Iteration 39 - Create EmailService interface and stub implementation
- Created EmailService.kt interface with sendPasswordResetEmail(toEmail, resetToken, userFirstName) method
- Created EmailServiceImpl.kt implementing EmailService with @Service annotation
- For MVP, implementation logs formatted email to console including reset URL
- Reset URL format: ${frontendUrl}/reset-password?token=${resetToken}
- Used @Value("\${app.frontend.url}") to inject frontend URL from application properties
- Added app.frontend.url: http://localhost:5173 configuration to application.yml
- Files changed:
  - src/main/kotlin/com/hackathon/manager/service/EmailService.kt (created)
  - src/main/kotlin/com/hackathon/manager/service/EmailServiceImpl.kt (created)
  - src/main/resources/application.yml (added frontend URL config)
  - PRD.md (marked US-005 complete)
- Learnings for future iterations:
  - EmailService interface allows swapping implementations later (SMTP, SendGrid, AWS SES) without changing dependent code
  - @Value annotation injects Spring Boot configuration properties into constructor parameters
  - application.yml follows hierarchical structure (app.frontend.url under app section)
  - MVP pattern: log emails to console for development, replace with real email service later
  - trimMargin() with pipe character creates clean multi-line string output
  - EmailServiceImpl will be injected into UserService later for sending password reset emails
---

## Iteration 40 - Add password reset methods to UserService
- Injected PasswordResetTokenRepository, EmailService, and PasswordEncoder into UserService constructor
- Added requestPasswordReset(email) method that creates token with 15-minute expiry and calls email service
- Silently succeeds if email doesn't exist (security: don't reveal user existence)
- Invalidates any existing unused tokens for the user by marking them as used
- Added validateResetToken(token) method that checks token exists, not used, not expired
- Added resetPassword(token, newPassword) method that validates token, updates user password, marks token as used
- Uses passwordEncoder.encode() for hashing new password
- Throws ApiException with BAD_REQUEST if token invalid/expired/used
- Files changed:
  - src/main/kotlin/com/hackathon/manager/service/UserService.kt
  - PRD.md (marked US-006 complete)
- Learnings for future iterations:
  - User entity id field is nullable (UUID? = null) because it's auto-generated, use !! operator when accessing for persisted entities
  - requestPasswordReset() invalidates existing unused tokens by marking usedAt = OffsetDateTime.now() rather than deleting
  - Token generation uses UUID.randomUUID().toString() for cryptographic randomness
  - validateResetToken() is separate method with @Transactional(readOnly = true) for reusability
  - resetPassword() calls validateResetToken() first, then updates user password and marks token as used
  - Service methods follow pattern: inject dependencies in constructor, use @Transactional annotations
  - PasswordEncoder is standard Spring Security dependency injected from AppConfig.kt
  - OffsetDateTime.now().plusMinutes(15) creates 15-minute expiry timestamp
---

## Iteration 41 - Add password validation helper
- Added validatePassword(password: String) private method in UserService
- Method checks four requirements: length >= 8, uppercase letter, lowercase letter, number
- Uses Regex pattern matching: [A-Z], [a-z], [0-9]
- Throws ApiException with BAD_REQUEST and descriptive message for each validation failure
- Integrated validation into resetPassword() method before password encoding
- Files changed:
  - src/main/kotlin/com/hackathon/manager/service/UserService.kt
  - PRD.md (marked US-007 complete)
- Learnings for future iterations:
  - Password validation uses String.contains(Regex("pattern")) for checking character requirements
  - Separate validation checks provide specific error messages for better UX
  - validatePassword() is private helper method since it's only used within UserService
  - Validation runs before encoding to avoid wasting CPU cycles on invalid passwords
  - Password requirements match registration flow (defined in Register.tsx) for consistency
  - Regex patterns wrapped in Regex() constructor: Regex("[A-Z]"), Regex("[a-z]"), Regex("[0-9]")
---

## Iteration 42 - Add password reset endpoints to AuthController
- Added POST /api/auth/forgot-password endpoint that accepts ForgotPasswordRequest
- Added POST /api/auth/reset-password endpoint that accepts ResetPasswordRequest
- Both endpoints are public (no authentication required)
- forgot-password always returns success message even if email doesn't exist (security best practice)
- reset-password validates passwords match before calling service, returns 400 if they don't match
- Injected UserService into AuthController constructor
- Updated AuthControllerTest to include UserService as MockBean to fix test failures
- Files changed:
  - src/main/kotlin/com/hackathon/manager/controller/AuthController.kt
  - src/test/kotlin/com/hackathon/manager/controller/AuthControllerTest.kt
  - PRD.md (marked US-008 complete)
- Learnings for future iterations:
  - ApiException constructor takes message first, then HttpStatus: ApiException(message, status)
  - When adding new dependencies to controller, must add corresponding @MockBean in test files
  - Controller endpoints follow pattern: @PostMapping, @Valid @RequestBody for validation, ResponseEntity for responses
  - Password validation (match check) happens in controller layer before calling service
  - Security best practice: always return same success message for forgot-password regardless of email existence
  - All AuthController endpoints now include: register, login, refresh, forgot-password, reset-password
---

## Iteration 43 - Add password reset confirmation email
- Added sendPasswordChangeConfirmation(toEmail, userFirstName) method to EmailService interface
- Implemented method in EmailServiceImpl to log confirmation message to console
- Message informs user their password was changed and suggests contacting support if not them
- Called method at end of UserService.resetPassword() after successful password update
- Files changed:
  - src/main/kotlin/com/hackathon/manager/service/EmailService.kt
  - src/main/kotlin/com/hackathon/manager/service/EmailServiceImpl.kt
  - src/main/kotlin/com/hackathon/manager/service/UserService.kt
  - PRD.md (marked US-009 complete)
- Learnings for future iterations:
  - EmailService interface extended with new method, EmailServiceImpl implements it following same console logging pattern
  - sendPasswordChangeConfirmation follows same MVP pattern as sendPasswordResetEmail (console logging)
  - Method called at end of resetPassword() after all database operations complete (password updated, token marked as used)
  - User details (email, firstName) accessed from resetToken.user which was already fetched earlier in the method
  - Security pattern: notify users of password changes so they're aware if account was compromised
  - Confirmation email is fire-and-forget (no error handling) since email service is async/logging only in MVP
---

## Iteration 44 - Add TypeScript types for password reset
- Added three password reset interfaces to frontend/src/types/index.ts
- Added ForgotPasswordRequest with email field
- Added ResetPasswordRequest with token, newPassword, confirmPassword fields
- Added PasswordResetResponse with message field
- Types added after RegisterRequest for logical grouping of auth-related types
- Files changed:
  - frontend/src/types/index.ts
  - PRD.md (marked US-010 complete)
- Learnings for future iterations:
  - TypeScript types should match backend DTOs for consistency (ForgotPasswordRequest matches backend data class)
  - Password reset types follow same pattern as existing auth types (LoginRequest, RegisterRequest)
  - ResetPasswordRequest includes both newPassword and confirmPassword for frontend validation
  - PasswordResetResponse is simple wrapper with message field (matches backend DTO)
  - Build command (npm run build) runs tsc -b for type checking, verifies all types are valid
  - Types placed near related auth types (after RegisterRequest) for better organization
---

## Iteration 45 - Add password reset methods to auth service
- Added forgotPassword(email) and resetPassword(token, newPassword, confirmPassword) methods to authService
- Both methods use centralized api client with skipAuth: true for public endpoints
- forgotPassword posts to /auth/forgot-password endpoint
- resetPassword posts to /auth/reset-password endpoint with token and passwords
- Added imports for ForgotPasswordRequest, ResetPasswordRequest, PasswordResetResponse types
- Files changed:
  - frontend/src/services/auth.ts
  - PRD.md (marked US-011 complete)
- Learnings for future iterations:
  - Password reset methods follow same pattern as login/register (skipAuth: true for public endpoints)
  - authService object is singleton with methods using api.post<ResponseType>()
  - Type casting with `as ForgotPasswordRequest` ensures proper type safety when passing objects to api.post
  - Password reset methods placed between refreshToken and logout for logical grouping
  - Both methods return Promise<PasswordResetResponse> for consistent response handling
  - No session management needed for password reset (unlike login/register which call setSession)
---

## Iteration 46 - Create ForgotPassword page
- Created ForgotPassword.tsx page following Login.tsx pattern
- Implemented React Hook Form with Zod schema validating email format
- Added email input field with Mail icon in left position
- Added "Send Reset Link" button with loading state (Loader2 icon and "Sending..." text)
- Success message shown with CheckCircle icon in green box: "If an account exists with that email, you will receive a password reset link shortly."
- Error message shown in red box if API call fails
- Added "Back to Login" link at bottom of form
- Uses AuthLayout with title "Forgot your password?" and descriptive subtitle
- Files changed:
  - frontend/src/pages/ForgotPassword.tsx (created)
  - PRD.md (marked US-012 complete - except browser verification)
- Learnings for future iterations:
  - ForgotPassword page follows exact same pattern as Login page (form structure, error handling, layout)
  - Success state managed with useState<boolean> to show success message after submission
  - Success message uses bg-green-50 text-green-700 with CheckCircle icon for positive feedback
  - AuthLayout title and subtitle props provide consistent header styling across auth pages
  - authService.forgotPassword() returns Promise<PasswordResetResponse> but we only care about success/error
  - Success message intentionally vague ("If an account exists...") to prevent email enumeration attacks
  - "Back to Login" link pattern mirrors "Create account" link in Login page for consistency
---

## Iteration 47 - Create ResetPassword page
- Created ResetPassword.tsx page following ForgotPassword and Register patterns
- Implemented React Hook Form with Zod schema matching Register.tsx password validation (8+ chars, uppercase, lowercase, number)
- Extracted token from URL query params using useSearchParams() from react-router-dom
- Shows error layout when token is missing from URL with "Request New Link" button
- Added newPassword and confirmPassword fields with Lock icons in left position
- Password requirements displayed as helper text below fields (bulleted list with all 4 requirements)
- Added "Reset Password" button with loading state (Loader2 icon and "Resetting Password..." text)
- On success, navigates to /login with success message in location state
- Error message shown in red box if API call fails (invalid/expired token)
- Uses AuthLayout with title "Reset your password" and subtitle
- Files changed:
  - frontend/src/pages/ResetPassword.tsx (created)
  - PRD.md (marked US-013 complete - except browser verification)
- Learnings for future iterations:
  - useSearchParams() from react-router-dom returns [searchParams, setSearchParams] tuple
  - searchParams.get("token") extracts query parameter from URL
  - Early return pattern when token missing shows error layout before main form
  - Password validation schema uses .refine() to check passwords match, similar to Register page
  - navigate() can accept state object to pass success messages to next page
  - Password requirements helper text uses text-xs, list-disc, list-inside, and ml-2 for proper list formatting
  - ResetPassword follows same structure as ForgotPassword but with password fields instead of email
  - Both password fields use Lock icon for consistency with Login page
---

## Iteration 48 - Add password reset routes to App
- Imported ForgotPasswordPage and ResetPasswordPage in App.tsx
- Added /forgot-password route as public route (no authentication required)
- Added /reset-password route as public route (no authentication required)
- Both routes placed after login and register, before protected routes
- Files changed:
  - frontend/src/App.tsx
  - PRD.md (marked US-014 complete except browser verification)
- Learnings for future iterations:
  - Password reset routes should be public routes (outside ProtectedRoute wrapper)
  - Import order follows pattern: auth pages (Login, Register, ForgotPassword, ResetPassword) then protected pages
  - Public routes placed at top of Routes, before protected routes section
  - Route definitions follow consistent pattern: <Route path="/forgot-password" element={<ForgotPasswordPage />} />
  - Both password reset pages already exist and follow proper patterns from previous iterations
  - Frontend build and typecheck passes successfully
---

## Iteration 49 - Verify forgot password link functionality
- Verified Login.tsx already has Link to /forgot-password at lines 89-94
- No code changes required - task was verification only
- Tested forgot-password API endpoint returns 200 OK with proper message
- Tested reset-password API endpoint validates tokens correctly (returns 400 for invalid token)
- Verified frontend routes /forgot-password and /reset-password are accessible
- Confirmed frontend typechecks and builds successfully
- Files changed:
  - PRD.md (marked US-015 complete)
- Learnings for future iterations:
  - US-015 was a verification task, not an implementation task (no code changes needed)
  - "Forgot password?" link already existed in Login.tsx from initial implementation
  - Password reset flow fully functional: forgot-password endpoint â†’ reset-password endpoint
  - Both frontend pages (ForgotPassword, ResetPassword) and backend endpoints working correctly
  - API testing with curl confirms endpoints handle requests properly (success and error cases)
  - Verification tasks require testing but not necessarily code changes
---

## Iteration 50 - Add cleanup job for expired tokens
- Created ScheduledTasks.kt class in new scheduler package with @Component annotation
- Added cleanupExpiredPasswordResetTokens() method with @Scheduled(cron = "0 0 0 * * ?") to run daily at midnight
- Method calculates cutoffTime as 7 days ago using OffsetDateTime.now().minusDays(7)
- Calls passwordResetTokenRepository.deleteByExpiresAtBefore(cutoffTime) which returns count of deleted rows
- Logs deleted count at INFO level: "Cleaned up X expired password reset tokens older than 7 days"
- Added @EnableScheduling annotation to HackathonManagerApplication.kt main class
- Files changed:
  - src/main/kotlin/com/hackathon/manager/scheduler/ScheduledTasks.kt (created)
  - src/main/kotlin/com/hackathon/manager/HackathonManagerApplication.kt (added @EnableScheduling)
  - PRD.md (marked US-016 complete)
- Learnings for future iterations:
  - Scheduled tasks should be placed in scheduler package for organization
  - @Component annotation makes class a Spring bean for dependency injection
  - @Scheduled annotation requires @EnableScheduling on main application class to work
  - Cron expression "0 0 0 * * ?" means: second=0, minute=0, hour=0 (midnight), every day, every month, any day of week
  - deleteByExpiresAtBefore() repository method returns Int count of deleted rows for logging
  - Use SLF4J LoggerFactory.getLogger() for logging in Spring Boot components
  - OffsetDateTime.now().minusDays(7) creates timestamp 7 days in the past
  - Scheduled cleanup prevents unbounded database growth by removing old expired tokens
---
