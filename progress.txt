# Progress Log

## Learnings
(Patterns discovered during implementation)

---

## Iteration 1 - Add JWT decoding utility (US-001)
- Implemented JWT token decoding utility in `frontend/src/utils/jwt.ts`
- Created helper functions: `decodeToken()`, `getTokenExpiration()`, `isTokenExpired()`, `getTimeUntilExpiration()`
- Set up Vitest testing infrastructure for the frontend
- Added comprehensive unit tests (18 tests covering all edge cases)

Files changed:
- Created: `frontend/src/utils/jwt.ts` (JWT decoding utility)
- Created: `frontend/src/utils/jwt.test.ts` (comprehensive unit tests)
- Created: `frontend/vitest.config.ts` (Vitest configuration)
- Created: `frontend/src/test/setup.ts` (test setup with jest-dom)
- Modified: `frontend/package.json` (added Vitest dependencies and test scripts)
- Modified: `PRD.md` (marked US-001 as complete)

Learnings for future iterations:
- The project had no unit testing infrastructure, so Vitest was added
- Frontend uses TypeScript strict mode - all code must pass typecheck
- JWT tokens use URL-safe base64 encoding (- and _ instead of + and /)
- Use fixed timestamps in tests to avoid rounding issues with Date.now()
- Tests should be comprehensive: test both happy path and error cases
- Pattern: Create utility in `src/utils/`, tests in same directory with `.test.ts` suffix

---

## Iteration 2 - Implement proactive token refresh timer (US-002)
- Created TokenRefreshTimer class in `frontend/src/utils/refreshTimer.ts`
- Timer automatically refreshes tokens 5 minutes before expiration
- Integrated refresh timer with authService (starts on login/register/refresh, clears on logout)
- Added `initializeRefreshTimer()` to restart timer on app load
- Added comprehensive unit tests (17 tests covering all scenarios)

Files changed:
- Created: `frontend/src/utils/refreshTimer.ts` (refresh timer implementation)
- Created: `frontend/src/utils/refreshTimer.test.ts` (comprehensive unit tests)
- Modified: `frontend/src/services/auth.ts` (integrated refresh timer)
- Modified: `frontend/src/contexts/AuthContext.tsx` (initialize timer on app load)
- Modified: `PRD.md` (marked US-002 acceptance criteria as complete)

Learnings for future iterations:
- Timer uses singleton pattern with a single global instance
- Timer must clear itself after execution (set timerId to null in finally block)
- Use fake timers in tests (vi.useFakeTimers()) for reliable timing tests
- Async callbacks in tests require await vi.runAllTimersAsync() to complete
- Console logging for debugging is helpful for timer operations
- REFRESH_BUFFER_MS is 5 minutes (300 seconds) as per requirements
- Timer handles edge cases: immediate refresh if < 5 min remaining, invalid tokens
- authService now has startRefreshTimer() and initializeRefreshTimer() methods
- AuthContext initializes timer on mount when user is already logged in
- Timer is fully integrated: starts on login/register, restarts on refresh, clears on logout, initializes on app load

---

## Iteration 3 - Create session countdown UI component (US-003)
- Created SessionCountdown component that displays remaining session time
- Component shows countdown when < 10 minutes remain (unobtrusive)
- Updates every second using setInterval
- Conditional styling: yellow/warning when < 5 minutes, blue/normal when >= 5 minutes
- Fixed positioning in top-right corner (below navbar at top-16)
- Automatically hides when > 10 minutes remain
- Added comprehensive unit tests (18 tests covering all scenarios)

Files changed:
- Created: `frontend/src/components/SessionCountdown.tsx` (countdown component)
- Created: `frontend/src/components/SessionCountdown.test.tsx` (comprehensive unit tests)
- Modified: `PRD.md` (marked US-003 as complete)

Learnings for future iterations:
- Use `act()` from React Testing Library to wrap timer advances in tests
- Timer state updates must be wrapped in `act()` to avoid warnings
- Component visibility logic: only show when time is in specific range (< 10 min)
- Format time conditionally: show hours+minutes for > 1hr, minutes+seconds otherwise
- Use `window.clearInterval` instead of `global.clearInterval` for TypeScript
- Fixed positioning classes: `fixed top-16 right-4 z-40` places below navbar
- Accessibility: use `role="status"` and `aria-live="polite"` for screen readers
- Conditional CSS classes using template literals for warning vs normal states
- Component uses lucide-react icons (Clock icon) - consistent with existing patterns
- Test all edge cases: visibility thresholds, formatting, styling transitions, cleanup

---

## Iteration 4 - Display session timeout countdown notification (US-004)
- Created SessionTimeoutNotification component that warns users when < 5 minutes remain
- Component shows prominent yellow banner with countdown and action buttons
- Displays countdown timer in "Xm Ys" format, updating every second
- "Extend Session" button calls authService.refreshToken() to extend the session
- Dismiss button to temporarily hide notification (reappears on remount if still < 5 min)
- Fixed positioning below navbar (top-16) to be less intrusive than SessionExpiredBanner
- Added component to App.tsx alongside SessionExpiredBanner
- Added comprehensive unit tests (16 tests covering all functionality)

Files changed:
- Created: `frontend/src/components/SessionTimeoutNotification.tsx` (notification component)
- Created: `frontend/src/components/SessionTimeoutNotification.test.tsx` (comprehensive unit tests)
- Modified: `frontend/src/App.tsx` (added notification to app layout)
- Modified: `frontend/package.json` (added @testing-library/user-event dev dependency)
- Modified: `PRD.md` (marked most US-004 acceptance criteria as complete)

Learnings for future iterations:
- Banner-style notifications work well for important but not critical warnings
- Yellow (warning) color scheme is less alarming than red (destructive) for expiration warnings
- Position notifications below navbar (top-16) to avoid overlapping with navigation
- Use `fireEvent` from React Testing Library for simpler click tests (instead of userEvent)
- Testing async button handlers with fake timers can be tricky - test button render instead
- Dismiss functionality should use local state, not persist across remounts
- AnimatePresence from framer-motion needs mocking in tests to avoid timing issues
- The notification appears automatically when token has < 5 minutes, no manual triggering needed
- Keep notification z-index high (z-50) to ensure visibility over content
- Proper ARIA: use role="alert" with aria-live="polite" for screen readers

---

## Iteration 5 - Add activity tracking to API client (US-005)
- Implemented activity tracking in ApiClient to monitor meaningful user activity
- Tracks timestamp for POST, PUT, DELETE, PATCH requests (excludes GET requests)
- Activity timestamp stored in memory (not localStorage) as required
- Added patch() method to ApiClient for PATCH request support
- Exposed getLastActivityTime() method to retrieve last activity timestamp
- Added clearActivityTracking() method for test isolation
- Comprehensive unit tests (10 tests covering all scenarios)

Files changed:
- Modified: `frontend/src/services/api.ts` (added activity tracking logic)
- Created: `frontend/src/services/api.test.ts` (comprehensive unit tests)
- Modified: `frontend/src/components/SessionTimeoutNotification.test.tsx` (fixed unused import)
- Modified: `PRD.md` (marked US-005 as complete)

Learnings for future iterations:
- Activity tracking should happen BEFORE the fetch call to capture intent even if request fails
- Use `globalThis.fetch` instead of `global.fetch` for TypeScript compatibility
- Test isolation is critical for singleton instances - added clearActivityTracking() method
- The api.test.ts file needed to clear activity state in beforeEach() hook
- Activity tracking excludes GET requests per requirements (viewing â‰  active work)
- TypeScript strict mode requires all imports to be used (removed unused `waitFor`)
- Pattern: Track activity at the request() level to cover all HTTP methods uniformly
- The patch() method was added to complete REST method coverage
- Activity timestamp is reset to null on clearActivityTracking() for clean test state

---

## Iteration 6 - Backend endpoint to extend session on activity (US-006)
- Created POST /api/auth/extend-session endpoint that extends user sessions
- Endpoint requires authentication using @PreAuthorize("isAuthenticated()") annotation
- Implemented rate limiting (max 1 extend per minute per user) using in-memory ConcurrentHashMap
- Issues new access + refresh tokens with full duration (same as refresh endpoint)
- Returns AuthResponse format consistent with login/register/refresh endpoints
- Added 4 comprehensive unit tests covering success, unauthorized, rate limit, and not found cases

Files changed:
- Modified: `src/main/kotlin/com/hackathon/manager/service/AuthService.kt` (added extendSession method with rate limiting)
- Modified: `src/main/kotlin/com/hackathon/manager/controller/AuthController.kt` (added extend-session endpoint)
- Modified: `src/test/kotlin/com/hackathon/manager/controller/AuthControllerTest.kt` (added 4 unit tests + createUserPrincipal helper)
- Modified: `PRD.md` (marked US-006 as complete)

Learnings for future iterations:
- @PreAuthorize annotation allows specific endpoints under /api/auth/** to require authentication
- @AuthenticationPrincipal extracts the current user from SecurityContext automatically
- Use ConcurrentHashMap for thread-safe in-memory rate limiting in Spring Boot
- HttpStatus.TOO_MANY_REQUESTS (429) is the correct status for rate limit errors
- Testing authenticated endpoints requires .with(user(createUserPrincipal())) not @WithMockUser
- @WithMockUser creates generic Spring user, not our custom UserPrincipal type
- Pattern: Create createUserPrincipal() helper in tests for reusable mock user creation
- Import SecurityMockMvcRequestPostProcessors.user to use .with(user()) in tests
- Rate limiting calculates time difference using Duration.between(lastTime, now).seconds
- The endpoint doesn't need a request body since user ID comes from SecurityContext
- Existing refresh token logic can be reused for extend-session (generate new tokens)
- Always check existing test patterns before writing new tests (consistency is key)

---
